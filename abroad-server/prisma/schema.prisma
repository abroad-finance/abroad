// prisma/schema.prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["views"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Partner {
  id            String        @id @default(uuid())
  name          String
  createdAt     DateTime      @default(now())
  apiKey        String?       @unique
  clientDomainHash String?      @unique
  country       String?
  email         String?       @unique
  phone         String?
  firstName     String?
  lastName      String?
  isKybApproved Boolean?      @default(false)
  needsKyc      Boolean?      @default(true)
  webhookUrl    String?
  users         PartnerUser[]
  quotes        Quote[]
}

model PartnerUser {
  id               String           @id @default(uuid())
  partnerId        String
  partner          Partner          @relation(fields: [partnerId], references: [id])
  userId           String
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  transaction      Transaction[]
  kyc              PartnerUserKyc[]
  kycExternalToken String?

  // Unique constraint to ensure a user is only once per partner
  @@unique([partnerId, userId])
}

model PartnerUserKyc {
  id            String      @id @default(uuid())
  partnerUser   PartnerUser @relation(fields: [partnerUserId], references: [id])
  partnerUserId String

  externalId String
  status     KycStatus @default(PENDING)
  tier       KYCTier   @default(NONE)
  link       String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([partnerUserId, externalId])
}

model Quote {
  id             String            @id @default(uuid())
  targetAmount   Float
  sourceAmount   Float
  targetCurrency TargetCurrency
  paymentMethod  PaymentMethod
  country        Country
  cryptoCurrency CryptoCurrency
  network        BlockchainNetwork

  partnerId String
  partner   Partner @relation(fields: [partnerId], references: [id])

  expirationDate DateTime
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  transaction    Transaction?

  @@index([partnerId])
}

model Transaction {
  id            String            @id @default(uuid())
  partnerUserId String
  partnerUser   PartnerUser       @relation(fields: [partnerUserId], references: [id])
  accountNumber String
  bankCode      String            @default("")
  status        TransactionStatus
  createdAt     DateTime          @default(now())
  quoteId       String            @unique
  quote         Quote             @relation(fields: [quoteId], references: [id])
  onChainId     String?           @unique
  refundOnChainId String?         @unique
  taxId         String?
  externalId    String?           @unique
  qrCode        String?
  exchangeHandoffAt DateTime?
  transitions   TransactionTransition[]

  @@index([partnerUserId, status, createdAt], name: "transaction_partnerUser_status_createdAt_idx")
}

model StellarListenerState {
  id              String   @id @default("singleton")
  lastPagingToken String
  updatedAt       DateTime @updatedAt
}

model SolanaListenerState {
  id                String    @id
  lastSignature     String?
  lastProcessedTime DateTime?
  lastProcessedSlot Int
}

model StellarOrphanRefund {
  paymentId           String             @id
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  lastError           String?
  reason              String?
  refundTransactionId String?
  status              OrphanRefundStatus
}

model PendingConversions {
  source SupportedCurrency
  target SupportedCurrency
  amount Float
  symbol String
  side   OrderSide

  @@id([source, target])
}

model TransactionTransition {
  id             String            @id @default(uuid())
  transactionId  String
  transaction    Transaction       @relation(fields: [transactionId], references: [id])
  event          String
  fromStatus     TransactionStatus
  toStatus       TransactionStatus
  idempotencyKey String
  context        Json?
  createdAt      DateTime          @default(now())

  @@unique([transactionId, idempotencyKey])
  @@index([transactionId, createdAt])
}

enum OutboxStatus {
  PENDING
  DELIVERING
  DELIVERED
  FAILED
}

model OutboxEvent {
  id           String       @id @default(uuid())
  type         String
  payload      Json
  status       OutboxStatus @default(PENDING)
  attempts     Int          @default(0)
  lastError    String?
  availableAt  DateTime     @default(now())
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  @@index([status, availableAt])
}

enum KycStatus {
  PENDING
  APPROVED
  REJECTED
  PENDING_APPROVAL
}

enum TransactionStatus {
  AWAITING_PAYMENT
  PROCESSING_PAYMENT
  PAYMENT_FAILED
  PAYMENT_EXPIRED
  PAYMENT_COMPLETED
  WRONG_AMOUNT
}

enum OrderSide {
  BUY
  SELL
}

enum OrphanRefundStatus {
  PENDING
  FAILED
  SUCCEEDED
}

enum CryptoCurrency {
  USDC
}

enum KYCTier {
  NONE
  BASIC
  STANDARD
  ENHANCED
}

enum SupportedCurrency {
  USDC
  USDT
  COP
  BRL
}

enum BlockchainNetwork {
  STELLAR
  SOLANA
  CELO
}

enum Country {
  CO
}

enum PaymentMethod {
  NEQUI // Legacy: kept for historical records only
  MOVII // Legacy: kept for historical records only
  PIX
  BREB
}

enum TargetCurrency {
  COP
  BRL
}

enum FlowPricingProvider {
  BINANCE
  TRANSFERO
}

enum FlowCorridorStatus {
  SUPPORTED
  UNSUPPORTED
}

enum FlowStepType {
  PAYOUT_SEND
  EXCHANGE_SEND
  EXCHANGE_CONVERT
  TREASURY_TRANSFER
  AWAIT_PROVIDER_STATUS
  AWAIT_EXCHANGE_BALANCE
}

enum FlowStepCompletionPolicy {
  SYNC
  AWAIT_EVENT
}

enum FlowInstanceStatus {
  NOT_STARTED
  IN_PROGRESS
  WAITING
  FAILED
  COMPLETED
}

enum FlowStepStatus {
  READY
  RUNNING
  WAITING
  SUCCEEDED
  FAILED
  SKIPPED
}

model PaymentProvider {
  id        String   @id
  name      String
  liquidity Float
  country   Country
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model PartnerDailyLimit {
  id            String         @id @default(uuid())
  partnerId     String
  paymentMethod PaymentMethod
  day           DateTime
  amount        Float          @default(0)
  count         Int            @default(0)

  @@unique([partnerId, paymentMethod, day], name: "partner_method_day_unique")
}

model PartnerUserDailyLimit {
  id            String         @id @default(uuid())
  partnerUserId String
  paymentMethod PaymentMethod
  day           DateTime
  amount        Float          @default(0)
  count         Int            @default(0)

  @@unique([partnerUserId, paymentMethod, day], name: "partner_user_method_day_unique")
}

model PartnerMonthlyLimit {
  id            String         @id @default(uuid())
  partnerId     String
  paymentMethod PaymentMethod
  month         DateTime
  amount        Float          @default(0)
  count         Int            @default(0)

  @@unique([partnerId, paymentMethod, month], name: "partner_method_month_unique")
}

model PartnerUserMonthlyLimit {
  id            String         @id @default(uuid())
  partnerUserId String
  paymentMethod PaymentMethod
  month         DateTime
  amount        Float          @default(0)
  count         Int            @default(0)

  @@unique([partnerUserId, paymentMethod, month], name: "partner_user_method_month_unique")
}

view TransactionQuoteView {
  id                   String
  transactionStatus    TransactionStatus
  partnerUserId        String
  accountNumber        String
  bankCode             String
  transactionCreatedAt DateTime
  quoteId              String
  onChainId            String?
  refundOnChainId      String?
  taxId                String?
  externalId           String?
  qrCode               String?
  partnerId            String
  targetAmount         Float
  sourceAmount         Float
  targetCurrency       TargetCurrency
  paymentMethod        PaymentMethod
  country              Country
  cryptoCurrency       CryptoCurrency
  network              BlockchainNetwork
  expirationDate       DateTime
  quoteCreatedAt       DateTime
  quoteUpdatedAt       DateTime

  @@unique([id])
  @@map("TransactionQuoteView")
}

model FlowDefinition {
  id             String               @id @default(uuid())
  name           String
  enabled        Boolean              @default(true)
  cryptoCurrency CryptoCurrency
  blockchain     BlockchainNetwork
  targetCurrency TargetCurrency
  payoutProvider PaymentMethod
  pricingProvider FlowPricingProvider
  exchangeFeePct Float               @default(0)
  fixedFee       Float               @default(0)
  minAmount      Float?
  maxAmount      Float?
  userSteps      Json
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  steps          FlowStepDefinition[]

  @@unique([cryptoCurrency, blockchain, targetCurrency], name: "flow_corridor_unique")
}

model FlowCorridor {
  id             String             @id @default(uuid())
  cryptoCurrency CryptoCurrency
  blockchain     BlockchainNetwork
  targetCurrency TargetCurrency
  status         FlowCorridorStatus @default(UNSUPPORTED)
  reason         String?
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt

  @@unique([cryptoCurrency, blockchain, targetCurrency], name: "flow_corridor_status_unique")
}

model CryptoAssetConfig {
  id             String            @id @default(uuid())
  cryptoCurrency CryptoCurrency
  blockchain     BlockchainNetwork
  mintAddress    String?
  decimals       Int?
  enabled        Boolean           @default(true)
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  @@unique([cryptoCurrency, blockchain], name: "crypto_asset_unique")
}

model FlowStepDefinition {
  id               String                   @id @default(uuid())
  flowDefinitionId String
  flowDefinition   FlowDefinition           @relation(fields: [flowDefinitionId], references: [id], onDelete: Cascade)
  stepOrder        Int
  stepType         FlowStepType
  completionPolicy FlowStepCompletionPolicy
  config           Json
  signalMatch      Json?
  createdAt        DateTime                 @default(now())
  updatedAt        DateTime                 @updatedAt

  @@index([flowDefinitionId])
  @@unique([flowDefinitionId, stepOrder], name: "flow_step_order_unique")
}

model FlowInstance {
  id             String             @id @default(uuid())
  transactionId  String             @unique
  status         FlowInstanceStatus @default(NOT_STARTED)
  currentStepOrder Int?
  flowSnapshot   Json
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  steps          FlowStepInstance[]
}

model FlowStepInstance {
  id             String        @id @default(uuid())
  flowInstanceId String
  flowInstance   FlowInstance  @relation(fields: [flowInstanceId], references: [id], onDelete: Cascade)
  stepOrder      Int
  stepType       FlowStepType
  status         FlowStepStatus @default(READY)
  attempts       Int           @default(0)
  maxAttempts    Int           @default(3)
  input          Json?
  output         Json?
  error          Json?
  correlation    Json?
  startedAt      DateTime?
  endedAt        DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@index([flowInstanceId])
  @@unique([flowInstanceId, stepOrder], name: "flow_step_instance_order_unique")
}

model FlowSignal {
  id             String   @id @default(uuid())
  flowInstanceId String?
  stepInstanceId String?
  eventType      String
  correlationKeys Json
  payload        Json
  createdAt      DateTime @default(now())
  consumedAt     DateTime?

  @@index([eventType])
  @@index([consumedAt])
}
