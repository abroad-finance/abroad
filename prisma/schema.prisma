// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Partner {
  id            String        @id @default(uuid())
  name          String
  createdAt     DateTime      @default(now())
  apiKey        String?       @unique
  country       String?
  email         String?       @unique
  phone         String?
  firstName     String?
  lastName      String?
  isKybApproved Boolean?      @default(false)
  needsKyc      Boolean?      @default(true)
  webhookUrl    String?
  users         PartnerUser[]
  quotes        Quote[]
}

model PartnerUser {
  id               String        @id @default(uuid())
  partnerId        String
  partner          Partner       @relation(fields: [partnerId], references: [id])
  userId           String
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  transaction      Transaction[]
  kyc              PartnerUserKyc[]
  kycExternalToken String?

  // Unique constraint to ensure a user is only once per partner
  @@unique([partnerId, userId])
}

model PartnerUserKyc {
  id          String      @id @default(uuid())
  partnerUser PartnerUser @relation(fields: [partnerUserId], references: [id])
  partnerUserId String

  externalId  String
  status      KycStatus   @default(PENDING)
  tier        KYCTier     @default(NONE)
  link       String

  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@unique([partnerUserId, externalId])
  @@unique([partnerUserId, tier])
}

model Quote {
  id             String            @id @default(uuid())
  targetAmount   Float
  sourceAmount   Float
  targetCurrency TargetCurrency
  paymentMethod  PaymentMethod
  country        Country
  cryptoCurrency CryptoCurrency
  network        BlockchainNetwork

  partnerId String
  partner   Partner @relation(fields: [partnerId], references: [id])

  expirationDate DateTime
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  transaction    Transaction?

  @@index([partnerId])
}

model Transaction {
  id            String            @id @default(uuid())
  partnerUserId String
  partnerUser   PartnerUser       @relation(fields: [partnerUserId], references: [id])
  accountNumber String
  bankCode      String            @default("")
  status        TransactionStatus
  createdAt     DateTime          @default(now())
  quoteId       String            @unique
  quote         Quote             @relation(fields: [quoteId], references: [id])
  onChainId     String?           @unique
  taxId         String?
}

model StellarListenerState {
  id              String   @id @default("singleton")
  lastPagingToken String
  updatedAt       DateTime @updatedAt
}

model SolanaListenerState {
  id                String    @id
  lastSignature     String?
  lastProcessedTime DateTime?
  lastProcessedSlot Int
}

model PendingConversions {
  source SupportedCurrency
  target SupportedCurrency
  amount Float
  symbol String
  side   OrderSide

  @@id([source, target])
}

enum KycStatus {
  PENDING
  APPROVED
  REJECTED
  PENDING_APPROVAL
}

enum TransactionStatus {
  AWAITING_PAYMENT
  PROCESSING_PAYMENT
  PAYMENT_FAILED
  PAYMENT_COMPLETED
  WRONG_AMOUNT
}

enum OrderSide {
  BUY
  SELL
}

enum CryptoCurrency {
  USDC
}

enum KYCTier {
  NONE
  BASIC
  STANDARD
  ENHANCED
}

enum SupportedCurrency {
  USDC
  USDT
  COP
  BRL
}

enum BlockchainNetwork {
  STELLAR
  SOLANA
}

enum Country {
  CO
}

enum PaymentMethod {
  NEQUI
  MOVII
  PIX
}

enum TargetCurrency {
  COP
  BRL
}

model PaymentProvider {
  id        String   @id
  name      String
  liquidity Float
  country   Country
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
